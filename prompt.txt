===> main.go <===
package main

import (
	"L0-wb/database"
	"L0-wb/kafka"
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	fmt.Println("Connecting to Database")
	database.Connect()

	r.GET("/ping", func(c *gin.Context) {
		c.String(http.StatusOK, "pong")
	})

	fmt.Println("Starting HTTP Server")
	go r.Run("127.0.0.1:8080")

	broker := "localhost:9092"
	topic := "orders"
	groupID := "go-consumer-group"

	fmt.Println("Starting Kafka Consumer")
	go kafka.StartKafkaConsumer(broker, topic, groupID)

	select {} // блокировка main-потока, чтобы горутина жила
}
===> database/db.go <===
package database

import (
	"L0-wb/models"
	"fmt"
	"log"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

var db *gorm.DB

func Connect() {
	connStr := "host=localhost port=5432 user=admin password=admin dbname=l0_database sslmode=disable"

	var err error
	db, err = gorm.Open(postgres.Open(connStr), &gorm.Config{})

	if err != nil {
		log.Fatal("Failed to open DB conn: ", err)
	}

	err = db.AutoMigrate(&models.Payment{}, &models.Item{}, &models.Delivery{}, &models.Order{})
	if err != nil {
		log.Fatal("failed to migrate models to DB: ", err)
	}

	fmt.Println("DB connection established")
}
===> models/order.go <===
package models

import "gorm.io/gorm"

type Order struct {
	gorm.Model
	OrderUid    string `json:"order_uid"`
	TrackNumber string `json:"track_number"`
	Entry       string `json:"entry"`

	DeliveryID uint     `json:"-"`
	Delivery   Delivery `json:"delivery" gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`

	PaymentID uint    `json:"-"`
	Payment   Payment `json:"payment" gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`

	Items []Item `json:"items" gorm:"foreignKey:OrderID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`

	Locale            string `json:"locale"`
	InternalSignature string `json:"internal_signature"`
	CustomerId        string `json:"customer_id"`
	DeliveryService   string `json:"delivery_service"`
	ShardKey          string `json:"shard_key"`
	SmId              int    `json:"sm_id"`
	DateCreated       string `json:"date_created"`
	OofShard          string `json:"oof_shard"`
}
===> models/item.go <===
package models

import "gorm.io/gorm"

type Item struct {
	gorm.Model

	OrderID uint `json:"-"`

	ChrtId      int    `json:"chrt_id"`
	TrackNumber string `json:"track_number"`
	Price       int    `json:"price"`
	Rid         string `json:"rid"`
	Name        string `json:"name"`
	Sale        int    `json:"sale"`
	Size        string `json:"size"`
	TotalPrice  int    `json:"total_price"`
	NmId        int    `json:"nm_id"`
	Brand       string `json:"brand"`
	Status      int    `json:"status"`
}
===> models/delivery.go <===
package models

import "gorm.io/gorm"

type Delivery struct {
	gorm.Model
	Name    string `json:"name"`
	Phone   string `json:"phone"`
	Zip     string `json:"zip"`
	City    string `json:"city"`
	Address string `json:"address"`
	Region  string `json:"region"`
	Email   string `json:"email"`
}
===> models/payment.go <===
package models

import "gorm.io/gorm"

type Payment struct {
	gorm.Model
	Transaction  string `json:"transaction"`
	RequestId    string `json:"request_id"`
	Currency     string `json:"currency"`
	Provider     string `json:"provider"`
	Amount       int    `json:"amount"`
	PaymentDt    int    `json:"payment_dt"`
	Bank         string `json:"bank"`
	DeliveryCost int    `json:"delivery_cost"`
	GoodsTotal   int    `json:"goods_total"`
	CustomFee    int    `json:"custom_fee"`
}
===> kafka/consumer.go <===
package kafka

import (
	"L0-wb/models"
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/segmentio/kafka-go"
)

func StartKafkaConsumer(brokerAddress, topic, groupID string) {
	r := kafka.NewReader(kafka.ReaderConfig{
		Brokers:        []string{brokerAddress},
		Topic:          topic,
		GroupID:        groupID,
		MinBytes:       10e3, // 10KB
		MaxBytes:       10e6, // 10MB
		CommitInterval: 0,    // авто-ack каждый раз, когда читаем
	})

	fmt.Println("🟢 Kafka consumer started")

	for {
		m, err := r.ReadMessage(context.Background())
		if err != nil {
			log.Printf("❌ error reading message: %v", err)
			continue
		}

		order := models.Order{}
		err = json.Unmarshal(m.Value, &order)
		if err != nil {
			log.Printf("❌ error unmarshaling message: %v", err)
			continue
		}

		fmt.Printf("📩 Message at offset %d parsed successfully\n", m.Offset)
		fmt.Println(order)
	}
}
